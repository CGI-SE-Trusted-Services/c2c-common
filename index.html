<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
 | Generated by Apache Maven Doxia at Mar 16, 2016
 | Rendered using Apache Maven Fluido Skin 1.2.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Java Implementation of ITS Intelligent Transport Systems ETSI TS 103 097 - </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido.min.js"></script>

    
    <meta name="Date-Revision-yyyymmdd" content="20160316" />
    <meta http-equiv="Content-Language" content="en" />
    
        </head>
        <body class="topBarDisabled">
          
        
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>c2c-common</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
            
                  <li id="publishDate">Last Published: 2016-03-16</li>
                  <li class="divider">|</li> <li id="projectVersion">Version: 0.9.7</li>
                      
                
            
      
                  </ul>
      </div>

            <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
            
                                    <h3>Documentation</h3>
                  <ul>
                  <li class="none">
            <strong>Readme</strong>
          </li>
                  <li class="none">
                          <a href="LICENSE.txt" title="License">License</a>
            </li>
                  <li class="none">
                          <a href="https://github.com/pvendil/c2c-common" class="externalLink" title="Github">Github</a>
            </li>
                  <li class="none">
                          <a href="https://github.com/pvendil/c2c-common/releases" class="externalLink" title="Download">Download</a>
            </li>
          </ul>
                      
            
                
          <hr class="divider" />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
        <div id="bodyColumn"  class="span9" >
                                  
            <h1>Java Implementation of ITS Intelligent Transport Systems (ITS) Security Security header and certificate formats</h1><h1>ETSI TS 103 097 V1.1.1 and IEEE 1609.2 2015</h1><p>This is a library used to generate data structures from the ETSI TS 103 097 (EU) and IEEE 1609.2 2015 (US) specification.</p><h1>License</h1><p>The software is released under AGPL, see LICENSE.txt for more details. In order to get the software under a different licensing agreement please contact p.vendil (at) cgi.com</p><h1>Whats New in 0.9.7</h1>
<ul>
  <li>Added support for IEEE 1609.2 certificate (US standard)</li>
</ul><h1>Whats New in 0.9.6</h1>
<ul>
  <li>Improved automatic build of project.</li>
</ul><h1>Whats New in 0.9.5</h1>
<ul>
  <li>Interoperability testing of all aspects except encryption.</li>
  <li>Bug-fixes on signature generation where trailer field signature type wasnt included in the digest calculation.</li>
</ul><h1>Whats New in 0.9.0</h1>
<ul>
  <li>Ecies Encryption scheme support in DefaultCryptoManager</li>
  <li>Restructured the behaviour of CryptoManager verifySecuredMessage to throw InvalidITSSignatureException instead of returning a boolean</li>
</ul><h1>EU Standard ETSI TS 103 097 V1.1.1</h1><p>It supports generation of the following data structures will all related substructures:</p>
<ul>
  <li>Root CA Certificate</li>
  <li>Enrollment CA Certificate</li>
  <li>Authorization CA Certificate</li>
  <li>Enrollment Credential Certificate</li>
  <li>Authorization Ticket</li>
  <li>Secure Messages for CAM and DENM</li>
</ul><p>Encryption of generated Secure Messages is not implemented in the current version. </p><p>See Javadoc and examples below for more detailed information.</p><p>Version 0.9.5 and above have been inter-operability tested with the site <a class="externalLink" href="https://werkzeug.dcaiti.tu-berlin.de/etsi/ts103097/">https://werkzeug.dcaiti.tu-berlin.de/etsi/ts103097/</a> and all version 1 Certificate and signed SecuredMessages v1 is successfully verified.</p><p><i>Important</i>: Encryped Secured Messages are still not fully inter-operability tested and might contain problems.</p><div class="section"><h2>Example Code<a name="Example_Code"></a></h2><p>Full example code can be seen in src/test/java/org/certificateservices/custom/c2x/demo it contains demo of both ITS (EU) and IEEE (US) standards.</p><p>Before doing anything else you need to initialize a CryptoManager used for all cryptographic operations.</p>
<div class="source"><pre class="prettyprint">    	//Create a crypto manager in charge of communicating with underlying cryptographic components
	    CryptoManager cryptoManager = new DefaultCryptoManager();	
	    // Initialize the crypto manager to use soft keys using the bouncy castle cryptographic provider.
	    cryptoManager.setupAndConnect(new DefaultCryptoManagerParams(&quot;BC&quot;));
</pre></div><div class="section"><h3>Root CA<a name="Root_CA"></a></h3><p>Example code on how to generate Root a CA, use the AuthorityCertGenerator:</p>
<div class="source"><pre class="prettyprint">        // Create an authority certificate generator and initialize it with the crypto manager. 
	    AuthorityCertGenerator authorityCertGenerator = new AuthorityCertGenerator(cryptoManager);
	    
	    // Generate a reference to the Root CA Signing Keys	    
	    KeyPair rootCASigningKeys = cryptoManager.generateKeyPair(PublicKeyAlgorithm.ecdsa_nistp256_with_sha256);
	    
	    // Generate the list of ITS AID values for the Root CA
	    List&lt;BigInteger&gt; rootCAItsAidList = new ArrayList&lt;BigInteger&gt;();
	    rootCAItsAidList.add(new BigInteger(&quot;1&quot;));
	    
	    // Generate the root CA Certificate, without any encryption keys or geographic region.
	    Certificate rootCACertificate = authorityCertGenerator.genRootCA(&quot;TestRootCA&quot;.getBytes(&quot;UTF-8&quot;), // subjectName
	    		rootCAItsAidList, //itsAidList 
	    		4, // assuranceLevel 
                3, // confidenceLevel 
	    		new Date(), // validFrom 
                new Date(System.currentTimeMillis() + 1000 * 3600* 24 * 365 * 10), // validTo, 10 years in this example 
	    		null, // geographicRegion
	    		PublicKeyAlgorithm.ecdsa_nistp256_with_sha256, // signingPublicKeyAlgorithm 
	    		rootCASigningKeys.getPublic(), // signPublicKey,
	    		rootCASigningKeys.getPrivate(), // signPrivateKey,
                null, // encPublicKeyAlgorithm
                null); // encPublicKey

</pre></div></div><div class="section"><h3>Enrollment CA<a name="Enrollment_CA"></a></h3><p>To generate an Enrollment CA:</p>
<div class="source"><pre class="prettyprint">        // Generate a reference to the Enrollment CA Signing Keys        
	    KeyPair enrollmentCASigningKeys = cryptoManager.generateKeyPair(PublicKeyAlgorithm.ecdsa_nistp256_with_sha256);
	    
	    // Generate the list of ITS AID values for the Enrollment CA
	    List&lt;BigInteger&gt; enrollmentCAItsAidList = new ArrayList&lt;BigInteger&gt;();
	    enrollmentCAItsAidList.add(new BigInteger(&quot;2&quot;));

	    // Generate a reference to the Enrollment CA Signing Keys
	    Certificate enrollmentCACertificate =authorityCertGenerator.genEnrollmentAuthorityCA(
	    		&quot;TestEnrollmentCA&quot;.getBytes(&quot;UTF-8&quot;),//subjectName 
	    		enrollmentCAItsAidList, //itsAidList 
	    		4, //assuranceLevel 
	    		3, //confidenceLevel 
	    		new Date(), // validFrom 
                new Date(System.currentTimeMillis() + 1000 * 3600* 24 * 365 * 10), // validTo, 10 years in this example 
	    		null, // geographicRegion
	    		PublicKeyAlgorithm.ecdsa_nistp256_with_sha256, // signingPublicKeyAlgorithm 
	    		enrollmentCASigningKeys.getPublic(), 
                null, // encPublicKeyAlgorithm
                null, // encPublicKey
	    		rootCASigningKeys.getPrivate(), 
	    		rootCACertificate);

</pre></div></div></div><div class="section"><h2>Authority CA<a name="Authority_CA"></a></h2><p>To generate an Authority CA:</p>
<div class="source"><pre class="prettyprint">        // Generate a reference to the Authorization CA Signing Keys	    
	    KeyPair authorityCASigningKeys = cryptoManager.generateKeyPair(PublicKeyAlgorithm.ecdsa_nistp256_with_sha256);
	    
	    // Generate the list of ITS AID values for the Authorization CA
	    List&lt;BigInteger&gt; authorityCAItsAidList = new ArrayList&lt;BigInteger&gt;();
	    authorityCAItsAidList.add(new BigInteger(&quot;3&quot;));

	    // Generate a reference to the Authorization CA Signing Keys
	    Certificate authorityCACertificate = authorityCertGenerator.genAuthorizationAuthorityCA(
	    		&quot;TestAuthorizationCA&quot;.getBytes(&quot;UTF-8&quot;),//subjectName 
	    		enrollmentCAItsAidList, //itsAidList 
	    		4, //assuranceLevel 
	    		3, //confidenceLevel 
	    		new Date(), // validFrom 
                new Date(System.currentTimeMillis() + 1000 * 3600* 24 * 365 * 10), // validTo, 10 years in this example 
	    		null, // geographicRegion
	    		PublicKeyAlgorithm.ecdsa_nistp256_with_sha256, // signingPublicKeyAlgorithm 
	    		authorityCASigningKeys.getPublic(), 
                null, // encPublicKeyAlgorithm
                null, // encPublicKey
	    		rootCASigningKeys.getPrivate(), 
	    		rootCACertificate);

</pre></div><div class="section"><h3>Enrollment Credential<a name="Enrollment_Credential"></a></h3><p>To create an Enrollment Credential use the EnrollmentCredentialCertGenerator.</p>
<div class="source"><pre class="prettyprint">        // First we create a Enrollment Credential Cert Generator using the newly created Enrollment CA.
        EnrollmentCredentialCertGenerator enrollmentCredentialCertGenerator = new EnrollmentCredentialCertGenerator(cryptoManager, enrollmentCACertificate, enrollmentCASigningKeys.getPrivate());
	    // Next we generate keys for an enrollment credential.
	    KeyPair enrollmentCredentialSigningKeys = cryptoManager.generateKeyPair(PublicKeyAlgorithm.ecdsa_nistp256_with_sha256);
	    // Next we generate keys for an enrollment credential.
	    KeyPair enrollmentCredentialEncryptionKeys = cryptoManager.generateKeyPair(PublicKeyAlgorithm.ecdsa_nistp256_with_sha256);

	    // Generate the list of ITS AID values for the enrollment credential
	    List&lt;BigInteger&gt; enrollCredItsAidList = new ArrayList&lt;BigInteger&gt;();
	    enrollCredItsAidList.add(new BigInteger(&quot;4&quot;));
	    // Then use the following command to generate a enrollment credential
	    Certificate enrollmentCredential = enrollmentCredentialCertGenerator.genEnrollmentCredential(
	    		SignerInfoType.certificate,//signerInfoType 
	    		&quot;TestEnrollmentCredential&quot;.getBytes(&quot;UTF-8&quot;),// subjectName 
	    		enrollCredItsAidList,// itsAidList 
	    		4,// assuranceLevel 
	    		3,// confidenceLevel 
	    		new Date(), // validFrom 
                new Date(System.currentTimeMillis() + 1000 * 3600* 24 * 365 * 10), // validTo, 10 years in this example 
	    		null,// geographicRegion 
	    		PublicKeyAlgorithm.ecdsa_nistp256_with_sha256,// signingPublicKeyAlgorithm 
	    		enrollmentCredentialSigningKeys.getPublic(),// signPublicKey 
	    		PublicKeyAlgorithm.ecies_nistp256,// encPublicKeyAlgorithm 
	    		enrollmentCredentialEncryptionKeys.getPublic() // encPublicKey
	    		);
</pre></div></div><div class="section"><h3>Authorization Ticket<a name="Authorization_Ticket"></a></h3><p>To create an Authorization Ticket l use the AuthorizationTicketCertGenerator.</p>
<div class="source"><pre class="prettyprint">        // Authorization Tickets are created by the AuthorizationTicketCertGenerator
	    AuthorizationTicketCertGenerator authorizationTicketCertGenerator = new AuthorizationTicketCertGenerator(cryptoManager, authorityCACertificate, authorityCASigningKeys.getPrivate());
	    
	    // Next we generate keys for an authorization ticket.
	    KeyPair authorizationTicketSigningKeys = cryptoManager.generateKeyPair(PublicKeyAlgorithm.ecdsa_nistp256_with_sha256);
	    
	    // Next we generate keys for an authorization ticket.
	    KeyPair authorizationTicketEncryptionKeys = cryptoManager.generateKeyPair(PublicKeyAlgorithm.ecdsa_nistp256_with_sha256);
	    
	    // Generate the list of ITS AID values for the Authorization Ticket
	    List&lt;BigInteger&gt; authTicketItsAidList = new ArrayList&lt;BigInteger&gt;();
	    authTicketItsAidList.add(new BigInteger(&quot;4&quot;));
	    
	    Certificate authorizationTicket = authorizationTicketCertGenerator.genAuthorizationTicket(
	    		SignerInfoType.certificate,//signerInfoType 
	    		enrollCredItsAidList,// itsAidList 
	    		4,// assuranceLevel 
	    		3,// confidenceLevel 
	    		new Date(), // validFrom 
                new Date(System.currentTimeMillis() + 1000 * 3600* 24 * 365 * 10), // validTo, 10 years in this example 
	    		null,// geographicRegion 
	    		PublicKeyAlgorithm.ecdsa_nistp256_with_sha256,// signingPublicKeyAlgorithm 
	    		authorizationTicketSigningKeys.getPublic(),// signPublicKey 
	    		PublicKeyAlgorithm.ecies_nistp256,// encPublicKeyAlgorithm 
	    		authorizationTicketEncryptionKeys.getPublic()); // encPublicKey
</pre></div></div><div class="section"><h3>Secured Messages<a name="Secured_Messages"></a></h3><p>To create Secured Messages use the SecuredMessageGenerator.</p>
<div class="source"><pre class="prettyprint">        // Secure Messages are created by the Secure Message Generator
	    SecuredMessageGenerator securedMessageGenerator = new SecuredMessageGenerator(cryptoManager, PublicKeyAlgorithm.ecdsa_nistp256_with_sha256, authorizationTicket, authorityCASigningKeys.getPrivate(), PublicKeyAlgorithm.ecies_nistp256, authorizationTicketEncryptionKeys.getPrivate());
	    
	    // Next to generate a CAM Message, supported SignerIntoTypes are certificate_digest_with_ecdsap256 and certificate
	    SecuredMessage signedCAMMessage = securedMessageGenerator.genSignedCAMMessage(SignerInfoType.certificate_digest_with_ecdsap256, &quot;SomeMessageData&quot;.getBytes(&quot;UTF-8&quot;));
	    
	    byte[] someHash = {0x01,0x02,0x03};
	   // To Generate a CAM Unreqognized certificates message
	    List&lt;HashedId3&gt; unrecognizedCertificates = new ArrayList&lt;HashedId3&gt;();
	    unrecognizedCertificates.add(new HashedId3(someHash));	    
		SecuredMessage unReqognizedMessages= securedMessageGenerator.genSignedCAMUnrecognizedCertificatesMessage(SignerInfoType.certificate, unrecognizedCertificates);
		
		// To Generate a DENM Message
		ThreeDLocation generationLocation = new ThreeDLocation(900000000, 1800000000 , 100);
		SecuredMessage signedDENMMessage = securedMessageGenerator.genSignedDENMMessage(generationLocation, &quot;SomeMessageData&quot;.getBytes(&quot;UTF-8&quot;));
</pre></div></div><div class="section"><h3>Encrypted Secured Messages<a name="Encrypted_Secured_Messages"></a></h3><p>Neither CAM nor DENM messages should be encrypted, so in this example is a SecureMessage built manually</p>
<div class="source"><pre class="prettyprint">		List&lt;HeaderField&gt; headerFields = new ArrayList&lt;HeaderField&gt;();
		headerFields.add(new HeaderField(new Time64(new Date()))); // generate generation time
		headerFields.add(new HeaderField(generationLocation));
        headerFields.add(new HeaderField(123)); // Just have any value since no known message type uses encryption
        
        // There is no need to add recipient_info or encryption_parameters, these will be calculated and appended automatically by the crypto manager.
		List&lt;Payload&gt; payloadFields = new ArrayList&lt;Payload&gt;();
		// The payload that should be encrypted should have type encrypted, others will be ignored.
		payloadFields.add(new Payload(PayloadType.encrypted,&quot;SomeClearText&quot;.getBytes(&quot;UTF-8&quot;)));
		
		SecuredMessage secureMessage = new SecuredMessage(SecuredMessage.DEFAULT_SECURITY_PROFILE, headerFields, payloadFields);
		
		// First we create a list of receipients certificates that should be able to decrypt the payload.
		List&lt;Certificate&gt; receipients = new ArrayList&lt;Certificate&gt;();
		receipients.add(authorizationTicket);
		
		// Then we use the cryptoManager to create a cloned message with encrypted payload.
		SecuredMessage encryptedMessage = cryptoManager.encryptSecureMessage(secureMessage, PublicKeyAlgorithm.ecies_nistp256, receipients);
		
		// Verify that the payload data have been replaced with it's encrypted content.
		assert !(new String(encryptedMessage.getPayloadFields().get(0).getData(), &quot;UTF-8&quot;).equals(&quot;SomeClearText&quot;));
		
		// To decrypt we need the receivers certificate and the related private key.
		SecuredMessage decryptedMessage = cryptoManager.decryptSecureMessage(encryptedMessage, authorizationTicket, authorizationTicketEncryptionKeys.getPrivate());
		
		// Verify that the payload is in clear text again. 
		assert new String(decryptedMessage.getPayloadFields().get(0).getData(), &quot;UTF-8&quot;).equals(&quot;SomeClearText&quot;);
</pre></div></div><div class="section"><h3>Encrypted And Signed Secured Messages<a name="Encrypted_And_Signed_Secured_Messages"></a></h3><p>In this example we generate messages with payload type signed_and_encrypted, i.e the data is both signed and encrypted.</p>
<div class="source"><pre class="prettyprint">		// We start with constructing a secured message
		headerFields = new ArrayList&lt;HeaderField&gt;();
		headerFields.add(new HeaderField(new Time64(new Date()))); // generate generation time
		headerFields.add(new HeaderField(generationLocation));
        headerFields.add(new HeaderField(123)); // Just have any value since no known message type uses encryption
        
        // There is no need to add recipient_info or encryption_parameters, these will be calculated and appended automatically by the crypto manager.
		payloadFields = new ArrayList&lt;Payload&gt;();
		// The payload that should be encrypted should have type encrypted, others will be ignored.
		payloadFields.add(new Payload(PayloadType.signed_and_encrypted,&quot;SomeClearText&quot;.getBytes(&quot;UTF-8&quot;)));
		
		secureMessage = new SecuredMessage(SecuredMessage.DEFAULT_SECURITY_PROFILE, headerFields, payloadFields);
		
		SecuredMessage encryptedAndSignedMessage = cryptoManager.encryptAndSignSecureMessage(secureMessage, enrollmentCredential, SignerInfoType.certificate, 
				PublicKeyAlgorithm.ecdsa_nistp256_with_sha256, 
				enrollmentCredentialSigningKeys.getPrivate(), 
				PublicKeyAlgorithm.ecies_nistp256, receipients);
		
		
		assert encryptedAndSignedMessage.getTrailerFields().get(0).getTrailerFieldType() == TrailerFieldType.signature;
		// Verify that the payload data have been replaced with it's encrypted content.
		assert !(new String(encryptedAndSignedMessage.getPayloadFields().get(0).getData(), &quot;UTF-8&quot;).equals(&quot;SomeClearText&quot;));
		
		// To verify and decrypt the message use the following method, if signer info type is certificate_digest_with_ecdsap256, you need to verify with
		// alternative method where signer certificate is specified.
		SecuredMessage decryptedAndVerifiedMessage = cryptoManager.verifyAndDecryptSecuredMessage(encryptedAndSignedMessage, authorizationTicket, 
		authorizationTicketEncryptionKeys.getPrivate());
		assert new String(decryptedAndVerifiedMessage.getPayloadFields().get(0).getData(), &quot;UTF-8&quot;).equals(&quot;SomeClearText&quot;);

</pre></div></div><div class="section"><h3>To Encode and Decode Certificates and Secured Messages<a name="To_Encode_and_Decode_Certificates_and_Secured_Messages"></a></h3>
<div class="source"><pre class="prettyprint">        // To encode a certificate to a byte array use the following method
	    byte[] certificateData = authorizationTicket.getEncoded();
	    
	    // To decode certificate data use the following constructor
	    Certificate decodedCertificate = new Certificate(certificateData);

        // To encode a secured message to a byte array use the following method.
	    byte[] messageData = signedDENMMessage.getEncoded();
	    
	    // To decode message data use the following constructor.
	    SecuredMessage decodedMessage = new SecuredMessage(messageData);
</pre></div><h1>US Standard IEEE 1609.2</h1><p>The implementation supports the following:</p>
<ul>
  <li>Encodes using ASN.1 COER</li>
  <li>Support for both ecdsaNistP256 and ecdsaBrainpoolP256r1 algorithm schemes</li>
  <li>Generation of RootCA, Enrollment CA (Long Term) and Authorization (Short Term) CA</li>
  <li>Generation of Enrollment Certificates and Authorization Certificate</li>
  <li>Support for both explicit and implicit certificate generation</li>
  <li>Support signing and encryption of SecuredData structures</li>
  <li>Generation of SecuredCRL structures.</li>
</ul><p><i>Important</i>: The encryption scheme hasnt been properly tested for inter-operability yet and might contain wrong ECIES parameters.</p></div></div><div class="section"><h2>Example Code<a name="Example_Code"></a></h2><p>Full example code can be seen in src/test/java/org/certificateservices/custom/c2x/demo it contains demo of both ITS (EU) and IEEE (US) standards.</p><p>Before doing anything else you need to initialize a CryptoManager used for all cryptographic operations.</p>
<div class="source"><pre class="prettyprint">    	//Create a crypto manager in charge of communicating with underlying cryptographic components
	    CryptoManager cryptoManager = new DefaultCryptoManager();	
	    // Initialize the crypto manager to use soft keys using the bouncy castle cryptographic provider.
	    cryptoManager.setupAndConnect(new DefaultCryptoManagerParams(&quot;BC&quot;));
	    
</pre></div><div class="section"><h3>Root CA<a name="Root_CA"></a></h3><p>Example code on how to generate Root a CA, use the AuthorityCertGenerator:</p>
<div class="source"><pre class="prettyprint">        // Create an authority certificate generator and initialize it with the crypto manager. 
	    AuthorityCertGenerator authorityCertGenerator = new AuthorityCertGenerator(cryptoManager);
	    
	    // Generate a reference to the Root CA Keys	    
	    KeyPair rootCASigningKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    KeyPair rootCAEncryptionKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    
	    CertificateId rootCAId = new CertificateId(new Hostname(&quot;Test RootCA&quot;));
	    ValidityPeriod rootCAValidityPeriod = new ValidityPeriod(new Date(), DurationChoices.years, 45);
	    List&lt;Integer&gt; countries = new ArrayList&lt;Integer&gt;();
	    countries.add(SWEDEN);
		GeographicRegion region = GeographicRegion.generateRegionForCountrys(countries);
		
	    // Generate the root CA Certificate, without any encryption keys or geographic region.
	    Certificate rootCACertificate = authorityCertGenerator.genRootCA(rootCAId, // CertificateId
	    		rootCAValidityPeriod, //ValidityPeriod
	    		region, //GeographicRegion
	    		4, // assuranceLevel 
                3, // confidenceLevel 
                3, // minChainDepth
                -1, // chainDepthRange
	    		SignatureChoices.ecdsaNistP256Signature, //signingPublicKeyAlgorithm
	    		rootCASigningKeys.getPublic(), // signPublicKey
	    		rootCASigningKeys.getPrivate(), // signPrivateKey
	    		SymmAlgorithm.aes128Ccm, // symmAlgorithm
	    		BasePublicEncryptionKeyChoices.ecdsaNistP256,  // encPublicKeyAlgorithm
	    		rootCAEncryptionKeys.getPublic()); // encPublicKey
	    		
</pre></div></div><div class="section"><h3>Enrollment CA (Long Term)<a name="Enrollment_CA_Long_Term"></a></h3><p>To generate an Enrollment CA:</p>
<div class="source"><pre class="prettyprint">	    // Generate a reference to the Enrollment CA Keys	    
	    KeyPair enrollmentCASigningKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    KeyPair enrollmentCAEncryptionKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    
	    CertificateId enrollmentCAId = new CertificateId(new Hostname(&quot;Test Enrollment CA&quot;));
	    ValidityPeriod enrollmentCAValidityPeriod = new ValidityPeriod(new Date(), DurationChoices.years, 37);
	    
		byte[] cracaid = Hex.decode(&quot;010203&quot;); // Some cracaid
		PsidSspRange[] subjectPerms = new PsidSspRange[1];
		subjectPerms[0] = new PsidSspRange(new Psid(5), new SspRange(SspRangeChoices.all, null)); // Insert proper subject permissions here.
	    // Generate a reference to the Enrollment CA Signing Keys
	    Certificate enrollmentCACertificate =authorityCertGenerator.genLongTermEnrollmentCA(
	    		CertificateType.explicit, // Implicit or Explicit certificate
	    		enrollmentCAId,// CertificateId
				enrollmentCAValidityPeriod, 
				region,  //GeographicRegion
				subjectPerms,
				cracaid,
				99, // CrlSeries
	    		4, // assuranceLevel 
                3, // confidenceLevel 
                2, // minChainDepth
                0, // chainDepthRange
                SignatureChoices.ecdsaNistP256Signature, //signingPublicKeyAlgorithm
                enrollmentCASigningKeys.getPublic(), // signPublicKey, i.e public key in certificate
				rootCACertificate, // signerCertificate
				rootCASigningKeys.getPublic(), // signCertificatePublicKey, must be specified separately to support implicit certificates.
				rootCASigningKeys.getPrivate(),
	    		SymmAlgorithm.aes128Ccm, // symmAlgorithm
	    		BasePublicEncryptionKeyChoices.ecdsaNistP256,  // encPublicKeyAlgorithm
	    		enrollmentCAEncryptionKeys.getPublic() // encryption public key
	    		);
	    		
</pre></div></div><div class="section"><h3>Authorization CA (Short Term)<a name="Authorization_CA_Short_Term"></a></h3><p>To generate an Authorization CA:</p>
<div class="source"><pre class="prettyprint">	    // Generate a reference to the Authorization CA Keys	    
	    KeyPair authorityCASigningKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    KeyPair authorityCAEncryptionKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    
	    CertificateId authorityCAId = new CertificateId(new Hostname(&quot;Test Enrollment CA&quot;));
	    ValidityPeriod authorityCAValidityPeriod = new ValidityPeriod(new Date(), DurationChoices.years, 15);
	    
		cracaid = Hex.decode(&quot;040506&quot;); // Some cracaid
		subjectPerms = new PsidSspRange[1];
		subjectPerms[0] = new PsidSspRange(new Psid(6), new SspRange(SspRangeChoices.all, null)); // Insert proper subject permissions here.

	    // Generate a reference to the Authorization CA Signing Keys
	    Certificate authorityCACertificate = authorityCertGenerator.genAuthorizationCA(
	    		CertificateType.explicit, // Implicit or Explicit certificate
	    		authorityCAId,// CertificateId
	    		authorityCAValidityPeriod, 
				region,  //GeographicRegion
				subjectPerms,
				cracaid,
				99, // Some CrlSeries
	    		4, // assuranceLevel 
                3, // confidenceLevel 
                2, // minChainDepth
                0, // chainDepthRange
                SignatureChoices.ecdsaNistP256Signature, //signingPublicKeyAlgorithm
                authorityCASigningKeys.getPublic(), // signPublicKey, i.e public key in certificate
				rootCACertificate, // signerCertificate
				rootCASigningKeys.getPublic(), // signCertificatePublicKey,
				rootCASigningKeys.getPrivate(),
	    		SymmAlgorithm.aes128Ccm, // symmAlgorithm
	    		BasePublicEncryptionKeyChoices.ecdsaNistP256,  // encPublicKeyAlgorithm
	    		authorityCAEncryptionKeys.getPublic() // encryption public key
	    		);
	    		
</pre></div></div><div class="section"><h3>Enrollment Certificate<a name="Enrollment_Certificate"></a></h3><p>To create an Enrollment Certificate (explicit in this example) use the EnrollmentCertGenerator.</p>
<div class="source"><pre class="prettyprint">	    // First we create a Enrollment Credential Cert Generator using the newly created Enrollment CA.
	    EnrollmentCertGenerator enrollmentCredentialCertGenerator = new EnrollmentCertGenerator(cryptoManager);
	    // Next we generate keys for an enrollment credential.
	    KeyPair enrollmentCredentialSigningKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    // Next we generate keys for an enrollment credential.
	    KeyPair enrollmentCredentialEncryptionKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);

	    CertificateId enrollCertId = new CertificateId(Hex.decode(&quot;0102030405060708&quot;));
	    ValidityPeriod enrollCertValidityPeriod = new ValidityPeriod(new Date(), DurationChoices.years, 35);
	    
		PsidSspRange[] certRequestPermissions = new PsidSspRange[1];
		certRequestPermissions[0] = new PsidSspRange(new Psid(5), new SspRange(SspRangeChoices.all, null)); // Insert proper subject permissions here.
	    
	    // Then use the following command to generate a enrollment credential
	    Certificate enrollmentCredential = enrollmentCredentialCertGenerator.genEnrollCert(
	    		CertificateType.explicit, // Implicit or Explicit certificate
	    		enrollCertId, // Certificate Id,
	    		enrollCertValidityPeriod, 
	    		region, 
	    		certRequestPermissions, 
	    		cracaid, // insert proper cracaid here.
	    		99, // Some CrlSeries
	    		4, 
	    		3, 
	    		SignatureChoices.ecdsaNistP256Signature, //signingPublicKeyAlgorithm
	    		enrollmentCredentialSigningKeys.getPublic(), // signPublicKey, i.e public key in certificate
	    		enrollmentCACertificate, // signerCertificate
	    		enrollmentCASigningKeys.getPublic(), // signCertificatePublicKey,
	    		enrollmentCASigningKeys.getPrivate(), 
	    		SymmAlgorithm.aes128Ccm, // symmAlgorithm 
	    		BasePublicEncryptionKeyChoices.ecdsaNistP256, // encPublicKeyAlgorithm
	    		enrollmentCredentialEncryptionKeys.getPublic() // encryption public key
	    		);
	    		
</pre></div></div><div class="section"><h3>Authorization Certificate (With implicit certificate)<a name="Authorization_Certificate_With_implicit_certificate"></a></h3><p>To create an Authorization Certificate (implicit in this example) use the AuthorizationCertGenerator.</p>
<div class="source"><pre class="prettyprint">	    // Authorization certificates are created by the AuthorizationCertGenerator
	    AuthorizationCertGenerator authorizationCertGenerator = new AuthorizationCertGenerator(cryptoManager);
	    
	    // Next we generate keys for an authorization certificate.
	    KeyPair authorizationCertRequestSigningKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    
	    // Next we generate keys for an authorization certificate.
	    KeyPair authorizationCertEncryptionKeys = cryptoManager.generateKeyPair(SignatureChoices.ecdsaNistP256Signature);
	    
	    CertificateId authorizationCertId = new CertificateId(Hex.decode(&quot;9999999999&quot;));
	    ValidityPeriod authorizationCertValidityPeriod = new ValidityPeriod(new Date(), DurationChoices.years, 35);
	    
	    
		PsidSsp[] appPermissions = new PsidSsp[1];
		appPermissions[0] = new PsidSsp(new Psid(6), null); // Insert proper app permissions here.
	    
	    // Generate a certificate as an implicit certificate.
	    Certificate authorizationCert = authorizationCertGenerator.genAuthorizationCert(
	    		CertificateType.implicit, // Implicit or Explicit certificate
	    		authorizationCertId, // Certificate Id,
	    		authorizationCertValidityPeriod, 
	    		region, 
	    		appPermissions, 
	    		cracaid, // insert proper cracaid here.
	    		99, // Some CrlSeries
	    		4, 
	    		3, 
	    		SignatureChoices.ecdsaNistP256Signature, //signingPublicKeyAlgorithm
	    		authorizationCertRequestSigningKeys.getPublic(), // signPublicKey, i.e public key in certificate
	    		authorityCACertificate, // signerCertificate
	    		authorityCASigningKeys.getPublic(), // signCertificatePublicKey,
	    		authorityCASigningKeys.getPrivate(), 
	    		SymmAlgorithm.aes128Ccm, // symmAlgorithm 
	    		BasePublicEncryptionKeyChoices.ecdsaNistP256, // encPublicKeyAlgorithm
	    		authorizationCertEncryptionKeys.getPublic() // encryption public key
	    		); 
	    
	    // Implicit certificate needs to have it's private key reconstructed. R is given inside the ImplicitCertificateData (which is the actual type of implicit certificates)
	    PrivateKey authorizationCertSigningPrivateKey = cryptoManager.reconstructImplicitPrivateKey(authorizationCert, 
	    		((ImplicitCertificateData) authorizationCert).getR(), 
	    		SignatureChoices.ecdsaNistP256Signature, 
	    		authorizationCertRequestSigningKeys.getPrivate(), authorityCASigningKeys.getPublic(),
	    		authorityCACertificate);
	    		
</pre></div></div><div class="section"><h3>Certificate Encoding and Decoding Example<a name="Certificate_Encoding_and_Decoding_Example"></a></h3><p>To encode and decode a certificate use:</p>
<div class="source"><pre class="prettyprint">	    // To encode a certificate to a byte array use the following method
	    byte[] certificateData = authorizationCert.getEncoded();
	    
	    // To decode certificate data use the following constructor
	    Certificate decodedCertificate = new Certificate(certificateData);

</pre></div></div><div class="section"><h3>Secured Data Example<a name="Secured_Data_Example"></a></h3><p>To generate signed and/or encrypted Secured Data use the SecuredMessageGenerator:</p>
<div class="source"><pre class="prettyprint">	    // Secure Messages are created by the Secure Message Generator
	    SecuredDataGenerator securedMessageGenerator = new SecuredDataGenerator(SecuredDataGenerator.DEFAULT_VERSION, cryptoManager, HashAlgorithm.sha256, SignatureChoices.ecdsaNistP256Signature);
	    
	    // It is then possible to create a signed message with the following code
	      // First generate a Header with
	    HeaderInfo hi = securedMessageGenerator.genHeaderInfo(
	    		123L, // psid Required, 
	    		null, // generationTime Optional
	    		null, // expiryTime Optional
	    		null, // generationLocation Optional
	    		null, // p2pcdLearningRequest Optional
	    		null, // cracaid Optional
	    		null, // crlSeries Optional 
	    		null, // encType Type of encryption when encrypting a message with a encryption key references in a signed message instead of a certificate. Optional
	    		null // encryptionKey Optional
	    		);
	    
	    // This method can be used to sign the data
	    Ieee1609Dot2Data signedData = securedMessageGenerator.genSignedData(hi, 
	    		&quot;TestData&quot;.getBytes(), // The actual payload message to sign. 
	    		SignerIdentifierType.HASH_ONLY, // One of  HASH_ONLY, SIGNER_CERTIFICATE, CERT_CHAIN indicating reference data of the signer to include in the message
	    		new Certificate[] {authorizationCert,authorityCACertificate, rootCACertificate}, // The chain is required even though it isn't included in
	    		  // the message if eventual implicit certificates need to have it's public key reconstructed.
	    		authorizationCertSigningPrivateKey); // Signing Key
	    
	    // The message can be encrypted with the method
	      // First construct a list of recipient which have the public key specified either as a symmetric key, certificate or in header of signed data
	      // In this example we will use certificate as reciever, see package org.certificateservices.custom.c2x.ieee1609dot2.generator.recipient for more details.
	    Ieee1609Dot2Data encryptedData = securedMessageGenerator.encryptData(BasePublicEncryptionKeyChoices.ecdsaNistP256, 
	    		  signedData.getEncoded(), new Recipient[] {new CertificateRecipient(enrollmentCredential)});
	      // It is also possible to encrypt using a pre shared key using the encryptDataWithPresharedKey() method.
	    
	    // It is also possible to sign and encrypt in one go.
	    byte[] encryptedAndSignedMessage = securedMessageGenerator.signAndEncryptData(hi, 
	    		&quot;TestData2&quot;.getBytes(), 
	    		SignerIdentifierType.HASH_ONLY, 
	    		new Certificate[] {authorizationCert,authorityCACertificate, rootCACertificate}, 
	    		authorizationCertSigningPrivateKey, // Important to use the reconstructed private key for implicit certificates
	    		BasePublicEncryptionKeyChoices.ecdsaNistP256, 
	    		new Recipient[] {new CertificateRecipient(enrollmentCredential)});
	    
	    // To decrypt and verify a signed message it is possible to use the following
	      // First build a truststore of trust anchors (root CA certificate or equivalent)
	    Map&lt;HashedId8, Certificate&gt; trustStore = securedMessageGenerator.buildCertStore(new Certificate[] {rootCACertificate});
	      // Second build a store of known certificate that might be referenced in the message.
	    Map&lt;HashedId8, Certificate&gt; certStore = securedMessageGenerator.buildCertStore(new Certificate[] {authorizationCert, authorityCACertificate});
	      // To decrypt build a reciever store of known decryption keys and related receiver info, this can be certificate, signed message containing encryption key
	      // in header, symmetric key or pre shared key.
	    Map&lt;HashedId8, Receiver&gt; recieverStore = securedMessageGenerator.buildRecieverStore(new Receiver[] { new CertificateReciever(enrollmentCredentialEncryptionKeys.getPrivate(), enrollmentCredential)});
		  // Finally perform the decryption with.
	    byte[] decryptedMessage = securedMessageGenerator.decryptAndVerifySignedData(encryptedAndSignedMessage, 
	    		certStore, 
	    		trustStore,
	    		recieverStore, 
	    		true, //requiredSignature true if message must be signed otherwise a IllegalArgument is throwm
	    		true //requireEncryption true if message must be encrypted otherwise a IllegalArgument is throwm
	    		);
	      // It is also possilbe to use the methods decryptData or verifySignedData (or verifyReferencedSignedData) for alternative methods to verify and decrypt messages.
	    

</pre></div></div><div class="section"><h3>Secured Data Encoding and Decoding Example<a name="Secured_Data_Encoding_and_Decoding_Example"></a></h3><p>To encode and decode a secured data use:</p>
<div class="source"><pre class="prettyprint">	    // To encode a secured message to a byte array use the following method.
	    byte[] messageData = signedData.getEncoded();
	    
	    // To decode message data use the following constructor.
	    Ieee1609Dot2Data decodedMessage = new Ieee1609Dot2Data(messageData);

</pre></div></div></div>
                  </div>
            </div>
      
    <hr/>

    <footer>
            <div class="container-fluid">
              <div class="row span16">Copyright &copy;                   2016.
          All Rights Reserved.      
            
      </div>

        
        
                </div>
    </footer>
  </body>
</html>
